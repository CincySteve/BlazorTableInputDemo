@page "/blazortableinputdemo"

@using System.Diagnostics

@namespace BlazorTableInputDemo

<PageTitle>Blazor Table Input Demo</PageTitle>

<h1>Blazor Table Demo</h1>

<div id="" class=""
     style="height: 350px">

    <table id="mytable" class="bbd-table">

        <thead>
            <tr>
                <td></td>
               
            @for (int col = 1; col < 5; col++)
                {
                <td>
                @CellsListOfLists[0][col].Index_Col
                </td>
                }
                
            </tr>
        </thead>

        <tbody>

            @for (int row = 0; row <= 10; row++)
                {
                int yearIndex = row;
                <tr>
                    <td contenteditable="false" class="RowHeader" style="width: 30px">
                        @CellsListOfLists[yearIndex][0].Index_Row
                    </td>

                    @for (int col = 1; col < 5; col++)
                        {
                        int colIndex = col;
                        TableCell cell = CellsListOfLists[yearIndex][colIndex];

                        @if (cell.CSSClass == enteredData)
                            {
                            <td class="@cell.CSSClass" contenteditable="false" style="width: @colWidth">
                                <input style="width:@colWidth"
                                    class="@cell.CSSClass"
                                    value="@cell.Value_Formatted"
                                    placeholder=""
                                    onFocus="this.select()"
                                    @onchange="@((ChangeEventArgs e) => OnChange(e, cell.Value_Formatted, cell.Index_Row, cell.Index_Col))"
                                    @onfocusin="@((FocusEventArgs e) => OnFocusIn(e, cell.Index_Row, cell.Index_Col))"
                                    @onfocusout="@((FocusEventArgs e) => OnFocusOut(e, cell.Value_Formatted, cell.Index_Row, cell.Index_Col))" />
                            </td>
                            }
                        else
                            {
                            <td class="@cell.CSSClass" contenteditable="false" style="width: @colWidth">

                                @* Adding this if gets around the problem as described (i.e. an entered value does not appear in the "next" cell 
                                following the one in which the value is entered, even though the input statements below are identical. Based on the
                                Focus events, it appears this hack causes a FocusOut on the "next" cell after the value is entered. *@
                                @if (colIndex%2 == 0)
                                    {
                                    <input style="width:@colWidth"
                                        class="@cell.CSSClass"
                                        value=""
                                        placeholder="@cell.Value_Formatted"
                                        onFocus="this.select()"
                                        @onchange="@((ChangeEventArgs e) => OnChange(e, cell.Value_Formatted, cell.Index_Row, cell.Index_Col))"
                                        @onfocusin="@((FocusEventArgs e) => OnFocusIn(e, cell.Index_Row, cell.Index_Col))"
                                        @onfocusout="@((FocusEventArgs e) => OnFocusOut(e, cell.Value_Formatted, cell.Index_Row, cell.Index_Col))" />
                                    }
                                else
                                    {
                                    <input style="width:@colWidth"
                                        class="@cell.CSSClass"
                                        value=""
                                        placeholder="@cell.Value_Formatted"
                                        onFocus="this.select()"
                                        @onchange="@((ChangeEventArgs e) => OnChange(e, cell.Value_Formatted, cell.Index_Row, cell.Index_Col))"
                                        @onfocusin="@((FocusEventArgs e) => OnFocusIn(e, cell.Index_Row, cell.Index_Col))"
                                        @onfocusout="@((FocusEventArgs e) => OnFocusOut(e, cell.Value_Formatted, cell.Index_Row, cell.Index_Col))" />
                                    }
                            </td>
                            }

                        } @*end colIndex*@

                </tr>

                } @*end year*@

        </tbody>
    </table>

</div>

@code
{
    ElementReference nextElem;
    // private bool toggle = false;

    private List<List<TableCell>> CellsListOfLists { get; set; } = new List<List<TableCell>>();
    private string colWidth = "75px";
    private string enteredData = "entereddata";
    private string defaultData = "defaultdata";
    private int count = 0;
    private TableCell lastCell = new TableCell();

    protected override void OnInitialized()
        {
        CellsListOfLists = new List<List<TableCell>>();

        // Create some data
        for (int rowIndex = 0; rowIndex <= 10; rowIndex++)
            {
            List<TableCell> rowCellList = new List<TableCell>();

            for (int colIndex = 0; colIndex < 5; colIndex++)
                {
                TableCell cell = new TableCell();
                cell.Index_Row = rowIndex;
                cell.Index_Col = colIndex;
                cell.ColName = $"Col_{colIndex}";
                cell.Value_Dec = (rowIndex + 1) * 10 + colIndex;
                cell.Value_Formatted = cell.Value_Dec.ToString("C0");
                cell.CSSClass = "defaultdata";

                rowCellList.Add(cell);
                } // next colSpec

            CellsListOfLists.Add(rowCellList);
            }

        // Make a couple of the cells entered data
        CellsListOfLists[3][3].CSSClass = enteredData;
        CellsListOfLists[3][4].CSSClass = enteredData;

        lastCell = CellsListOfLists[5][2];
        Debug.WriteLine($"\nOnInitialized: Row/Col(5/5) | Formatted({lastCell.Value_Formatted})");
        } // OnInitialized

    protected override async Task OnAfterRenderAsync(bool firstTime)
        {
        Debug.WriteLine($"{count.ToString("0000")} OnAfterRenderAsync: Row/Col({lastCell.Index_Row}/{lastCell.Index_Col}) "
       + $"| Dec Value({lastCell.Value_Dec}) | Formatted({lastCell.Value_Formatted})");
        }

    protected void OnChange(ChangeEventArgs e, string origFormattedValue, int year, int colIndex)
        {
        lastCell = CellsListOfLists[year][colIndex];
        count++;

        // var x0 = nextElem.Context;

        lastCell.CSSClass = enteredData;
        lastCell.Value_Dec = int.Parse((string)e.Value);
        lastCell.Value_Formatted = lastCell.Value_Dec.ToString("C0");
        Debug.WriteLine($"{count.ToString("0000")} OnChange: Row/Col({lastCell.Index_Row}/{lastCell.Index_Col}) "
        + $"| Orig Value({origFormattedValue}) | New Value({(string)e.Value}) ");

        //InvokeAsync(StateHasChanged);
        } // OnChange

    protected void OnFocusIn(FocusEventArgs e, int year, int colIndex)
        {
        lastCell = CellsListOfLists[year][colIndex];
        count++;

        Debug.WriteLine($"{count.ToString("0000")} OnFocusIn: Row/Col({lastCell.Index_Row}/{lastCell.Index_Col}) "
        + $"| Dec Value({lastCell.Value_Dec}) | Formatted({lastCell.Value_Formatted})");

        //InvokeAsync(StateHasChanged);
        } // OnFocusIn

    protected void OnFocusOut(FocusEventArgs e, string value, int year, int colIndex)
        {
        lastCell = CellsListOfLists[year][colIndex];
        count++;

        Debug.WriteLine($"{count.ToString("0000")} OnFocusOut: Row/Col({lastCell.Index_Row}/{lastCell.Index_Col}) "
            + $"| Dec Value({lastCell.Value_Dec}) | Formatted({lastCell.Value_Formatted})");
        } // OnFocusOut

}